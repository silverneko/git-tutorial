{"name":"Git-tutorial","tagline":"Git tutorial / cheatsheet for NTUCSIE pioneer camp.","body":"##Preface\r\nThis is intended to be a brief introduction to `git`.  \r\nEvery git command has it's own man page in the format of `git-<command>` (e.g. `man git-add`).  \r\nYou can always google for some much more detailed tutorials.\r\n\r\n##What is git\r\n> *git - the stupid content tracker*\r\n> \r\n> \"git\" can mean anything, depending on your mood.  \r\n - random three-letter combination that is pronounceable, and not\r\n   actually used by any common UNIX command.  The fact that it is a\r\n   mispronunciation of \"get\" may or may not be relevant.\r\n - stupid. contemptible and despicable. simple. Take your pick from the\r\n   dictionary of slang.\r\n - \"global information tracker\": you're in a good mood, and it actually\r\n   works for you. Angels sing, and a light suddenly fills the room.\r\n - \"goddamn idiotic truckload of sh*t\": when it breaks\r\n> \r\n> *from https://github.com/git/git#readme*\r\n\r\nA distributed revision control system first developed by Linus Torvalds to manage the Linux kernel's source code.  \r\nNow a widely used tool to manage software projects.  \r\n\r\n###Pros\r\n* Fast and scalable.\r\n* Distributed: Easy to collaboration with others and development on local machine.\r\n* Versioning: Rollback to an earlier working version if you've messed up the code.\r\n* Branches: Smart workflow.\r\n* Stupid content tracker: Even ~~EE students~~  monkeys know how to use it.\r\n\r\n###Cons\r\n* You have to learn it first.\r\n\r\n##Install git\r\n###If you're using Ubuntu\r\n```bash\r\n$ sudo add-apt-repository ppa:git-core/ppa\r\n$ sudo apt-get update\r\n$ sudo apt-get install git\r\n```\r\n###If you're using CSIE workstation\r\nIt's already installed.\r\n\r\n###If you're using mac\r\n1. Get homebrew.\r\n2. `$ brew install git`\r\n\r\n###If you're using Windows\r\nPlease don't use Windows.  \r\nIf you insist, this is the installer's link: https://git-scm.com/download/win  \r\nHowever, I strongly advise you to get used to a unix-like environment (e.g. csie workstation), because the reward will be tremendous.\r\n\r\n##Github\r\nA popular git repo hosting site. Many open source projects are hosted here.  \r\n~~Social network for geeks~~  \r\nAnyone can host *unlimited* number of git repos for *free* as long as the repo is public.  \r\nHowever, you can get the student pack (https://education.github.com/pack) and you get 5 *free* *private* repos and a bunch of coupons.  \r\nThis tutorial is also hosted on github: https://github.com/silverneko/git-tutorial  \r\n\r\n\r\nBitbucket is another git hosting site and it offers free *private* repos, \r\nbut it has limitation on number of collaborators.\r\n\r\n##How to use git\r\nLines starting with a dollar sign are shell commands.  \r\nOptions quoted with square brackets means it's optional.  \r\nOptions quoted with angle brackets means it's a must.  \r\n\r\n###git config\r\n```bash\r\n$ git config [--global] user.name  <INSERT NAME HERE>\r\n$ git config [--global] user.email <INSERT EMAIL HERE>\r\n$ git config [--global] push.default simple\r\n$ git config [--global] core.editor <INSERT YOUR FAVORITE TEXT EDITOR HERE>\r\n```\r\nSet/query git configs.  \r\nDrop the `--global` option if you only want to change the config for current repo.\r\n\r\n###git init\r\n```bash\r\n$ git init [directory]\r\n```\r\nCreates a git repository. Make a directory into a git repository.  \r\nIf `path name` is empty then it will init in the current directory.\r\n\r\n###git status\r\n```bash\r\n$ git status\r\n```\r\nShow the status.\r\n\r\n###git add\r\n```bash\r\n$ git add <file | directory>\r\n$ git add .\r\n$ git add --all\r\n```\r\nStage the changes.  \r\nThe first command adds files/directories into staging area.  \r\nThe second command stages **everything** in the working tree. **USE WITH CAUTION!!!**  \r\nThe third command stages everything and do `git rm` on removed files for you.\r\n\r\n###git rm\r\n```bash\r\n$ git rm [--cached] <file>\r\n$ git rm [--cached] -r <directory>\r\n```\r\nDelete files/directories from git's tracking list and working tree.  \r\nAdd `--cached` to remove *only* from the tracking list. (i.e. Untrack a file but don't delete it from working tree)\r\n\r\n###git mv\r\n```bash\r\n$ git mv <file> <path>\r\n```\r\nIt kinds of explains itself already.\r\n\r\n###git commit\r\n```bash\r\n$ git commit [-a] [-m <message>]\r\n$ git commit --amend\r\n```\r\nCommit the staged changes.  \r\n`-a` Automatically stages **tracked files** before commiting.  \r\n`-m <message>` Use `<message>` as the commit message. A meaningful message is always preferred.  \r\n`--amend` Replace the latest commit by a new commit. We often use this to fix typos in commit message. **USE WITH CAUTION!!!** *CHANGING THE HISTORY IS DANGEROUS, MAKE SURE YOU KNOW WHAT YOU'RE DOING.*  \r\n\r\n###git reset\r\n```bash\r\n$ git reset [file]\r\n$ git reset [--soft|--mixed|--hard|...] <commit>\r\n```\r\nThe first command removes files from staging area. (i.e. the opposite of `git add`)  \r\nThe second command rewrites commits like `git commit --amend`, read more in `man git-reset`. **BE EXTRA CAUTION AS YOU ARE REWRITING HISTORY (AGAIN)**  \r\n\r\n###git show\r\n```bash\r\n$ git show\r\n```\r\nShows many things. Try it yourself.\r\n\r\n###git log\r\n```bash\r\n$ git log [--all] [--stat] [--decorate] [--graph] [--pretty=<oneline|short|...>]\r\n```\r\nShow the commit log.  \r\nThere are a lot of options for this command, read more in `man git-log`.\r\n\r\n###git diff\r\n```bash\r\n$ git diff [--staged]\r\n$ git diff [commit1] [commit2]\r\n```\r\nIf no commits provided, show the diff of the working tree to the last commit. (i.e. show uncommit **unstaged** changes)  \r\nAdd `--staged` to show the diff of uncommit **staged** changes.  \r\nIf only `[commit1]` is provided, show the diff of the working tree and `[commit1]`.  \r\nIf `[commit1]` and `[commit2]` are provided, show the diff of the two commits.  \r\n\r\n###git branch\r\n```bash\r\n$ git branch [-v]\r\n```\r\nList all branches.  \r\nAdd `-v` for verbose.\r\n\r\n```bash\r\n$ git branch [-u <upstream>] <branchname>\r\n```\r\nCreate new branch `<branchname>`.  \r\nAdd `-u` to also set it's upstream to `<upstream>`.\r\n\r\n###git checkout\r\n```bash\r\n$ git checkout <branch|commit>\r\n```\r\nChange current branch or checkout a commit.\r\n\r\n###git merge\r\n```bash\r\n$ git merge <branchname>\r\n```\r\nMerge current branch with branch `<branchname>`.\r\n\r\n###git clone\r\n```bash\r\n$ git clone <repository> [directory]\r\n```\r\nClone repository into given directory.    \r\nIf `[directory]` is not given then git will try to make a new directory and the directory name is determined by `<repository>`.\r\n\r\n###git pull\r\n```bash\r\n$ git pull [remote] [branch]\r\n```\r\nPull remote changes and apply it to the current branch.  \r\nIf `[remote]` and `[branch]` are omitted, git will pull from current branch's upstream.\r\n\r\n###git push\r\n```bash\r\n$ git push [remote] [branch]\r\n```\r\nPush local changes to remote branch.  \r\nIf you've set `push.default` to `simple` then `[remote]` and `[branch]` can be omitted and it'll push to current branch's upstream.\r\n\r\n###git stash\r\n```bash\r\n$ git stash [--all]\r\n```\r\nStash uncommited changes and turn working tree *clean*.  \r\nUse `--all` to stash *untracked* files, too.\r\n\r\n```bash\r\n$ git stash pop\r\n```\r\nRestore stashed.\r\n\r\nWe often use `git stash` before `git pull` because `git pull` requires a clean working tree.\r\nA clean working tree can be obtained by doing a `git commit`, but sometimes the changes on working tree are too minor to commit.\r\nIn such cases we can do something like:\r\n```bash\r\n$ git stash --all          # stash the dirty tree\r\n$ git pull origin master   # get new changes from your co-workers\r\n$ git stash pop            # restore your working tree and continue working\r\n```\r\n\r\n###git blame\r\n```bash\r\n$ git blame <file>\r\n```\r\nShow what revision and author last modified each line of a file.\r\n\r\n###git tag\r\n```bash\r\n$ git tag -a <tag name> [-m <message>] [commit]\r\n$ git tag -d <tag name>\r\n```\r\nTag a commit.\r\n`-d` to delete a tag.\r\n\r\n##Simple workflow\r\n```\r\n 1.need new feature so open a feature branch\r\n  |              3.merge the completed feature back to master\r\n  v               v\r\n--+---+---+---+---+---+---+ master branch\r\n   \\             /\r\n    \\-+---+---+-/  feature branch\r\n      ^ 2.work on the new feature on a seperate branch\r\n```\r\n1. Open a new `feature` branch.\r\n2. Work on the new feature on `feature`, commit, testing, commit, debug, loop ...\r\n3. When the feature is complete, merge `feature` to `master`.\r\n4. Delete `feature` branch. (Optional)\r\n\r\nThis way your not-yet-done work won't mess up with other collaborator's work, because everyone is working on their own branch and only working code would be merge back into `master`.\r\n\r\n##References\r\n- Git's official documents, a bit prettier than man pages: http://git-scm.com/doc\r\n- Github's interactive git tutorial, try git: https://try.github.io/levels/1/challenges/1\r\n- Github's markdown guide, teachs you how to write in markdown: https://guides.github.com/features/mastering-markdown/\r\n- Random commit message generator: http://whatthecommit.com/\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}